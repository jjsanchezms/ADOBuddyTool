using CreateRoadmapADO.Domain.Entities;
using CreateRoadmapADO.Domain.Services;
using Microsoft.Extensions.Logging;

namespace CreateRoadmapADO.Domain.Services;

/// <summary>
/// Domain service for work item business logic operations
/// Encapsulates business rules and logic separate from infrastructure concerns
/// </summary>
public class WorkItemDomainService : IWorkItemDomainService
{
    private readonly ILogger<WorkItemDomainService> _logger;

    public WorkItemDomainService(ILogger<WorkItemDomainService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public WorkItemRetrievalStrategy DetermineRetrievalStrategy(bool isHygieneCheck, bool isSwagUpdate, bool isRoadmapGeneration)
    {
        if (isHygieneCheck)
        {
            return new WorkItemRetrievalStrategy
            {
                WorkItemTypes = "Feature, Release Train",
                StateFilter = "NOT IN ('Removed','Closed')",
                IncludeRelations = true,
                Description = "Hygiene checks require both Features and Release Trains with relations for completeness validation"
            };
        }

        if (isSwagUpdate)
        {
            return new WorkItemRetrievalStrategy
            {
                WorkItemTypes = "Feature, Release Train",
                StateFilter = "NOT IN ('Removed')", // Include closed Features for SWAG calculations
                IncludeRelations = true,
                Description = "SWAG updates require both Features and Release Trains (including closed Features) with relations"
            };
        }

        if (isRoadmapGeneration)
        {
            return new WorkItemRetrievalStrategy
            {
                WorkItemTypes = "Feature",
                StateFilter = "NOT IN ('Removed','Closed')",
                IncludeRelations = false,
                Description = "Roadmap generation focuses on active Features"
            };
        }

        throw new InvalidOperationException("At least one operation type must be specified for work item retrieval");
    }

    public WorkItemValidationResult ValidateWorkItem(WorkItem workItem)
    {
        var result = new WorkItemValidationResult { IsValid = true };

        // Basic required field validation
        if (string.IsNullOrWhiteSpace(workItem.Title))
        {
            result.Issues.Add("Title is required");
            result.IsValid = false;
            result.Severity = WorkItemValidationSeverity.Error;
        }

        if (string.IsNullOrWhiteSpace(workItem.WorkItemType))
        {
            result.Issues.Add("Work item type is required");
            result.IsValid = false;
            result.Severity = WorkItemValidationSeverity.Error;
        }

        // Business rule validations
        if (workItem.WorkItemType == "Feature")
        {
            ValidateFeatureWorkItem(workItem, result);
        }
        else if (workItem.WorkItemType == "Release Train")
        {
            ValidateReleaseTrainWorkItem(workItem, result);
        }

        return result;
    }

    public bool ShouldIncludeInRoadmap(WorkItem workItem)
    {
        // Business rules for roadmap inclusion
        if (workItem.WorkItemType != "Feature")
        {
            return false;
        }

        // Exclude removed or closed items
        if (workItem.State is "Removed" or "Closed")
        {
            return false;
        }

        // Exclude KTLO tasks
        if (!string.IsNullOrEmpty(workItem.Tags) &&
            workItem.Tags.Contains("WeeklyDeploymentTasks", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        return true;
    }

    public double CalculateReleaseTrainSwag(WorkItem releaseTrain, IEnumerable<WorkItem> features)
    {
        if (releaseTrain.WorkItemType != "Release Train")
        {
            _logger.LogWarning("SWAG calculation requested for non-Release Train work item: {WorkItemId}", releaseTrain.Id);
            return 0;
        }

        var featureList = features.ToList();
        if (!featureList.Any())
        {
            _logger.LogInformation("No features found for Release Train {WorkItemId}, SWAG is 0", releaseTrain.Id);
            return 0;
        }

        var totalSwag = featureList.Sum(f => f.Swag ?? 0);

        _logger.LogDebug("Calculated SWAG for Release Train {WorkItemId}: {TotalSwag} from {FeatureCount} features",
            releaseTrain.Id, totalSwag, featureList.Count);

        return totalSwag;
    }

    public bool IsAutoGenerated(WorkItem workItem)
    {
        if (string.IsNullOrEmpty(workItem.Tags))
        {
            return false;
        }

        return workItem.Tags.Split(';', StringSplitOptions.RemoveEmptyEntries)
            .Any(tag => tag.Trim().Equals("auto-generated", StringComparison.OrdinalIgnoreCase));
    }

    private void ValidateFeatureWorkItem(WorkItem workItem, WorkItemValidationResult result)
    {
        // Feature-specific validations
        if (workItem.Swag == null && workItem.State != "Closed")
        {
            result.Issues.Add("Active Features should have SWAG values");
            result.Severity = WorkItemValidationSeverity.Warning;
        }

        if (string.IsNullOrWhiteSpace(workItem.IterationPath))
        {
            result.Issues.Add("Features should have iteration path assigned");
            result.Severity = WorkItemValidationSeverity.Warning;
        }
    }

    private void ValidateReleaseTrainWorkItem(WorkItem workItem, WorkItemValidationResult result)
    {
        // Release Train specific validations
        if (string.IsNullOrWhiteSpace(workItem.StatusNotes))
        {
            result.Issues.Add("Release Trains should have status notes documentation");
            result.Severity = WorkItemValidationSeverity.Warning;
        }

        if (string.IsNullOrWhiteSpace(workItem.IterationPath))
        {
            result.Issues.Add("Release Trains should have iteration path assigned");
            result.Severity = WorkItemValidationSeverity.Warning;
        }
    }
}
