using CreateRoadmapADO.Presentation.Configuration;
using CreateRoadmapADO.Domain.Entities;
using CreateRoadmapADO.Infrastructure.AzureDevOps.Services;
using Microsoft.Extensions.Logging;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;

namespace CreateRoadmapADO.Infrastructure.AzureDevOps.Services;

/// <summary>
/// Service for Azure DevOps work item modifications
/// Focused on creating and updating work items
/// </summary>
public class AzureDevOpsWorkItemService : IAzureDevOpsWorkItemService, IDisposable
{
    #region Constants

    private const string ApiVersion = "7.0";
    private const string AutoGeneratedTag = "auto-generated";
    private const string JsonPatchMediaType = "application/json-patch+json";
    private const string JsonMediaType = "application/json";

    #endregion

    #region Private Fields

    private readonly HttpClient _httpClient;
    private readonly AzureDevOpsOptions _options;
    private readonly ILogger<AzureDevOpsWorkItemService> _logger;
    private readonly JsonSerializerOptions _jsonOptions;
    private readonly IAzureDevOpsRelationService _relationService;
    private readonly ISwagService _swagService;

    #endregion

    #region Constructor

    public AzureDevOpsWorkItemService(
        ILogger<AzureDevOpsWorkItemService> logger,
        IAzureDevOpsRelationService relationService,
        ISwagService swagService)
    {
        _options = ConfigurationReader.GetAzureDevOpsOptions();
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _relationService = relationService ?? throw new ArgumentNullException(nameof(relationService));
        _swagService = swagService ?? throw new ArgumentNullException(nameof(swagService));

        if (!_options.IsValid())
        {
            throw new InvalidOperationException("Azure DevOps configuration is invalid");
        }
        _httpClient = new HttpClient();
        ConfigureHttpClient();

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    #endregion

    #region Public Methods    /// <summary>
    /// Creates a Release Train work item with child items
    /// </summary>
    /// <param name="children">IDs of child work items</param>
    /// <param name="title">Title of the Release Train</param>
    /// <param name="areaPath">Area path for the Release Train</param>
    /// <param name="patternItemId">ID of the pattern work item that triggered this creation</param>
    /// <returns>The ID of the created Release Train work item</returns>
    public async Task<int> CreateReleaseTrainAsync(List<int> children, string title, string areaPath, int patternItemId = 0)
    {
        try
        {
            _logger.LogInformation("Creating Release Train '{Title}' with {Count} children", title, children.Count);            // Create the Release Train work item
            var releaseTrainId = await CreateWorkItemAsync("Release Train", title, areaPath);

            // Create relations to children
            if (children.Any())
            {
                await CreateRelationsAsync(releaseTrainId, children);
            }

            _logger.LogInformation("Successfully created Release Train #{ReleaseTrainId} with {Count} children", releaseTrainId, children.Count);
            return releaseTrainId;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating Release Train '{Title}'", title);
            throw;
        }
    }

    /// <summary>
    /// Updates a work item's title
    /// </summary>
    /// <param name="workItemId">ID of the work item to update</param>
    /// <param name="newTitle">The new title for the work item</param>
    /// <returns>Task representing the asynchronous operation</returns>
    public async Task UpdateWorkItemTitleAsync(int workItemId, string newTitle)
    {
        try
        {
            _logger.LogInformation("Updating work item #{WorkItemId} title to: {NewTitle}", workItemId, newTitle);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?api-version={ApiVersion}";

            var patchOperation = new[]
            {
                new { op = "add", path = "/fields/System.Title", value = newTitle }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, JsonPatchMediaType);

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to update work item title with status {StatusCode}: {ErrorContent}", response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to update work item title with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully updated work item #{WorkItemId} title", workItemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating work item #{WorkItemId} title", workItemId);
            throw;
        }
    }

    /// <summary>
    /// Updates a work item's SWAG (effort) value
    /// </summary>
    /// <param name="workItemId">ID of the work item to update</param>
    /// <param name="swagValue">The new SWAG value</param>
    /// <returns>Task representing the asynchronous operation</returns>
    public async Task UpdateWorkItemSwagAsync(int workItemId, double swagValue)
    {
        try
        {
            _logger.LogInformation("Updating work item #{WorkItemId} SWAG to: {SwagValue}", workItemId, swagValue);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?api-version={ApiVersion}";

            var patchOperation = new[]
            {
                new { op = "add", path = "/fields/Microsoft.VSTS.Scheduling.Effort", value = swagValue }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, JsonPatchMediaType);

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to update work item SWAG with status {StatusCode}: {ErrorContent}", response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to update work item SWAG with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully updated work item #{WorkItemId} SWAG", workItemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating work item #{WorkItemId} SWAG", workItemId);
            throw;
        }
    }

    /// <summary>
    /// Updates a work item's description with SWAG prefix
    /// </summary>
    /// <param name="workItemId">ID of the work item to update</param>
    /// <param name="swagValue">The SWAG value to add as prefix</param>
    /// <param name="originalStatusNotes">The original status notes</param>
    /// <returns>Task representing the asynchronous operation</returns>
    public async Task UpdateWorkItemStatusNotesWithSwagAsync(int workItemId, double swagValue, string originalStatusNotes)
    {
        try
        {
            _logger.LogInformation("Updating work item #{WorkItemId} status notes with SWAG prefix: {SwagValue}", workItemId, swagValue);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?api-version={ApiVersion}";

            // Remove existing SWAG prefix if present and add new one
            var cleanStatusNotes = _swagService.RemoveSwagPrefixFromDescription(originalStatusNotes);            // Add SWAG prefix to the cleaned status notes
            string newStatusNotes = $"[SWAG: {swagValue}]{cleanStatusNotes}";
            var patchOperation = new[]
            {
                new
                {
                    op = "add",
                    path = "/fields/Skype.StatusNotes",
                    value = newStatusNotes
                }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, JsonPatchMediaType);

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to update work item status notes with status {StatusCode}: {ErrorContent}", response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to update work item status notes with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully updated work item #{WorkItemId} status notes with SWAG prefix", workItemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating work item #{WorkItemId} status notes", workItemId);
            throw;
        }
    }

    #endregion

    #region Private Helper Methods

    private void ConfigureHttpClient()
    {
        var credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($":{_options.PersonalAccessToken}"));
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", credentials);
        _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(JsonMediaType));
    }
    private async Task<int> CreateWorkItemAsync(string workItemType, string title, string areaPath)
    {
        var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/${workItemType}?api-version={ApiVersion}";

        _logger.LogDebug($"Creating {workItemType} work item: {title}");

        var patchDocument = new[]
        {
            new { op = "add", path = "/fields/System.Title", value = title },
            new { op = "add", path = "/fields/System.AreaPath", value = areaPath },
            new { op = "add", path = "/fields/System.Tags", value = AutoGeneratedTag }
        };

        var jsonContent = JsonSerializer.Serialize(patchDocument, _jsonOptions);
        var content = new StringContent(jsonContent, Encoding.UTF8, JsonPatchMediaType);

        var response = await _httpClient.PostAsync(url, content);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            _logger.LogError($"Failed to create {workItemType} work item with status {response.StatusCode}: {errorContent}");
            throw new HttpRequestException($"Failed to create {workItemType} work item with status {response.StatusCode}: {errorContent}");
        }

        var responseContent = await response.Content.ReadAsStringAsync();
        var responseJson = JsonDocument.Parse(responseContent);
        var workItemId = responseJson.RootElement.GetProperty("id").GetInt32();

        _logger.LogInformation($"Successfully created {workItemType} work item #{workItemId}: {title}");
        return workItemId;
    }

    private async Task CreateRelationsAsync(int parentId, List<int> childrenIds)
    {
        _logger.LogDebug($"Creating relations for work item #{parentId} to {childrenIds.Count} children");

        foreach (var childId in childrenIds)
        {
            await _relationService.CreateRelationAsync(parentId, childId, "Auto-generated relation");
        }

        _logger.LogInformation($"Successfully created {childrenIds.Count} relations for work item #{parentId}");
    }

    #endregion

    #region Resource Management

    public void Dispose()
    {
        _httpClient?.Dispose();
    }

    #endregion
}

