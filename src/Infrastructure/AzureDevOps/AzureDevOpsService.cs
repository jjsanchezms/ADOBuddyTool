using CreateRoadmapADO.Presentation.Configuration;
using CreateRoadmapADO.Infrastructure.AzureDevOps.Interfaces;
using CreateRoadmapADO.Domain.Entities;
using Microsoft.Extensions.Logging;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;

namespace CreateRoadmapADO.Infrastructure.AzureDevOps;

/// <summary>
/// Service for interacting with Azure DevOps API
/// Provides functionality for querying work items, creating work items, and managing relationships
/// </summary>
public class AzureDevOpsService : IAzureDevOpsService
{
    #region Constants

    private const string ApiVersion = "7.0";
    private const string DefaultAreaPath = "SPOOL\\Resource Provider";
    private const string AutoGeneratedTag = "auto-generated";
    private const string WeeklyDeploymentTasksTag = "WeeklyDeploymentTasks";
    private const string JsonPatchMediaType = "application/json-patch+json";
    private const string JsonMediaType = "application/json";

    #endregion

    #region Private Fields

    private readonly HttpClient _httpClient;
    private readonly AzureDevOpsOptions _options;
    private readonly ILogger<AzureDevOpsService> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    #endregion

    #region Constructor and Configuration

    /// <summary>
    /// Initializes a new instance of the AzureDevOpsService
    /// </summary>
    /// <param name="logger">Logger instance for diagnostics</param>
    /// <exception cref="ArgumentNullException">Thrown when logger is null</exception>
    /// <exception cref="InvalidOperationException">Thrown when Azure DevOps configuration is invalid</exception>
    public AzureDevOpsService(ILogger<AzureDevOpsService> logger)
    {
        _options = ConfigurationReader.GetAzureDevOpsOptions();
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        if (!_options.IsValid())
        {
            throw new InvalidOperationException("Azure DevOps configuration is invalid");
        }

        _httpClient = new HttpClient();
        ConfigureHttpClient();

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }
    private void ConfigureHttpClient()
    {
        var credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($":{_options.PersonalAccessToken}"));
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", credentials);
        _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(JsonMediaType));
    }

    #endregion

    #region Public Query Methods

    public async Task<IEnumerable<WorkItem>> GetWorkItemsAsync(CancellationToken cancellationToken = default)
    {
        // Default to the legacy area path for backward compatibility
        return await GetWorkItemsAsync(1000, DefaultAreaPath, cancellationToken);
    }
    public async Task<IEnumerable<WorkItem>> GetWorkItemsAsync(int limit, string areaPath, CancellationToken cancellationToken = default)
    {
        // Default to Feature work items for backward compatibility
        return await GetWorkItemsAsync(limit, areaPath, "Feature", cancellationToken);
    }

    public async Task<IEnumerable<WorkItem>> GetWorkItemsAsync(int limit, string areaPath, string workItemType, CancellationToken cancellationToken = default)
    {
        try
        {
            // WIQL query to retrieve work items ordered by BacklogPriority, filtered by AreaPath, excluding Removed state and KTLO tasks
            var wiqlQuery = $"SELECT [System.Id] FROM WorkItems WHERE [System.WorkItemType] = '{workItemType}' AND [System.AreaPath] UNDER '{areaPath}' AND [System.State] NOT IN ('Removed','Closed') AND NOT [System.Tags] CONTAINS 'WeeklyDeploymentTasks' ORDER BY [Microsoft.VSTS.Common.StackRank] ASC, [System.Id] ASC";
            var workItemIds = await ExecuteWiqlQueryAsync(wiqlQuery, cancellationToken);

            // Take only the requested number of IDs
            var limitedIds = workItemIds.Take(Math.Min(limit, 1000));

            if (!limitedIds.Any())
            {
                _logger.LogInformation("No {WorkItemType} work items found.", workItemType);
                return Enumerable.Empty<WorkItem>();
            }

            _logger.LogInformation("Found {Count} {WorkItemType} work items, retrieving {Limit}", workItemIds.Count(), workItemType, limitedIds.Count());            // Get the full work item details for the limited set

            return await GetWorkItemsByIdsAsync(limitedIds, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving {WorkItemType} work items", workItemType);
            throw;
        }
    }
    public async Task<IEnumerable<WorkItem>> GetWorkItemsForHygieneChecksAsync(int limit, string areaPath, CancellationToken cancellationToken = default)
    {
        try
        {
            // WIQL query to retrieve both Feature and Release Train work items for hygiene checks
            var wiqlQuery = $"SELECT [System.Id] FROM WorkItems WHERE [System.WorkItemType] IN ('Feature', 'Release Train') AND [System.AreaPath] UNDER '{areaPath}' AND [System.State] NOT IN ('Removed','Closed') ORDER BY [Microsoft.VSTS.Common.StackRank] ASC, [System.Id] ASC";
            var workItemIds = await ExecuteWiqlQueryAsync(wiqlQuery, cancellationToken);

            // Take only the requested number of IDs
            var limitedIds = workItemIds.Take(Math.Min(limit, 1000));

            if (!limitedIds.Any())
            {
                _logger.LogInformation("No Feature or Release Train work items found for hygiene checks.");
                return Enumerable.Empty<WorkItem>();
            }

            _logger.LogInformation("Found {Count} Feature/Release Train work items for hygiene checks, retrieving {Limit}", workItemIds.Count(), limitedIds.Count());

            // Get the full work item details with relations for hygiene checks
            return await GetWorkItemsWithRelationsByIdsAsync(limitedIds, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving work items for hygiene checks");
            throw;
        }
    }
    public async Task<WorkItem?> GetWorkItemByIdAsync(int workItemId, CancellationToken cancellationToken = default)
    {
        try
        {
            var fields = "System.Id,System.Title,System.WorkItemType,System.State,System.Description,Skype.StatusNotes,System.IterationPath,System.Tags,Microsoft.VSTS.Common.StackRank,Skype.Swag";
            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?fields={fields}&api-version=7.0";

            _logger.LogDebug("Making request to: {Url}", url);

            var response = await _httpClient.GetAsync(url, cancellationToken);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
                _logger.LogWarning("Failed to retrieve work item {WorkItemId}. Status: {StatusCode}, Content: {Content}", workItemId, response.StatusCode, errorContent);
                return null;
            }

            var content = await response.Content.ReadAsStringAsync(cancellationToken);
            var workItemResponse = JsonSerializer.Deserialize<WorkItemResponse>(content, _jsonOptions);

            return ConvertToWorkItem(workItemResponse);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving work item {WorkItemId}", workItemId);
            throw;
        }
    }

    public async Task<WorkItem?> GetWorkItemWithRelationsAsync(int workItemId, CancellationToken cancellationToken = default)
    {
        try
        {
            // Include relations by using the $expand parameter (cannot use fields parameter with expand)
            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?$expand=relations&api-version=7.0";

            _logger.LogDebug("Making request to get work item with relations: {Url}", url);

            var response = await _httpClient.GetAsync(url, cancellationToken);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
                _logger.LogWarning("Failed to retrieve work item with relations {WorkItemId}. Status: {StatusCode}, Content: {Content}",
                    workItemId, response.StatusCode, errorContent);
                return null;
            }

            var content = await response.Content.ReadAsStringAsync(cancellationToken);
            var workItemResponse = JsonSerializer.Deserialize<WorkItemResponse>(content, _jsonOptions);

            return ConvertToWorkItemWithRelations(workItemResponse);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving work item with relations {WorkItemId}", workItemId);
            throw;
        }
    }

    public async Task<int> GetExistingRelatedParentItemIdAsync(int workItemId, CancellationToken cancellationToken = default)
    {
        try
        {
            // Get the work item with its relations
            var workItem = await GetWorkItemWithRelationsAsync(workItemId, cancellationToken);

            if (workItem == null || !workItem.Relations.Any())
                return 0;

            // Look for related items
            foreach (var relation in workItem.Relations)
            {
                // Check only "Related" links 
                if (relation.Rel == "System.LinkTypes.Related")
                {
                    var relatedId = relation.GetRelatedWorkItemId();
                    if (relatedId > 0)
                    {                        // Get the related work item
                        var relatedItem = await GetWorkItemByIdAsync(relatedId, cancellationToken);                        // Check if it's a Release Train with auto-generated tag and is not the current work item
                        if (relatedItem != null &&
                            relatedItem.WorkItemType == "Release Train" &&
                            !string.IsNullOrEmpty(relatedItem.Tags) &&
                            relatedItem.Tags.Split(';', StringSplitOptions.RemoveEmptyEntries)
                                .Any(tag => tag.Trim().Equals("auto-generated", StringComparison.OrdinalIgnoreCase)))
                        {
                            _logger.LogInformation("Found existing related auto-generated parent: #{RelatedId} ({Title})",
                                relatedId, relatedItem.Title);
                            return relatedId;
                        }
                    }
                }
            }

            // No matching related parent found
            return 0;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking for existing related parent for work item {WorkItemId}", workItemId);
            return 0;
        }
    }

    public async Task<IEnumerable<WorkItem>> GetWorkItemsByQueryAsync(string wiqlQuery, CancellationToken cancellationToken = default)
    {
        try
        {
            var workItemIds = await ExecuteWiqlQueryAsync(wiqlQuery, cancellationToken);

            if (!workItemIds.Any())
            {
                _logger.LogInformation("No work items found for the query");
                return Enumerable.Empty<WorkItem>();
            }

            return await GetWorkItemsByIdsAsync(workItemIds, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error executing WIQL query: {Query}", wiqlQuery);
            throw;
        }
    }

    public async Task<int> CreateReleaseTrainAsync(List<int> children, string title, string areaPath, int patternItemId = 0)
    {
        _logger.LogInformation("Creating Release Train with title: {Title}, patternItemId: {PatternItemId}", title, patternItemId);
        _logger.LogInformation("Child items: {ChildrenCount}", children.Count);
        Console.WriteLine($"Creating Release Train: {title}");
        Console.WriteLine($"With {children.Count} children: {string.Join(", ", children)}");

        try
        {            // Create the Release Train work item type
            var releaseTrainId = await CreateWorkItemAsync("Release Train", title, areaPath);

            if (releaseTrainId > 0)
            {
                // Create relations to child work items
                await CreateRelationsAsync(releaseTrainId, children);

                _logger.LogInformation("Successfully created Release Train #{ReleaseTrainId}: {Title}", releaseTrainId, title);
                Console.WriteLine($"Successfully created Release Train #{releaseTrainId}: {title}");
            }

            return releaseTrainId;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating Release Train: {Title}", title);
            Console.WriteLine($"Error creating Release Train: {ex.Message}");
            throw;
        }
    }
    public async Task CreateRelationAsync(int sourceId, int targetId, string comment = "")
    {
        try
        {
            _logger.LogInformation("Creating relation from #{SourceId} to #{TargetId}", sourceId, targetId);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{sourceId}?api-version=7.0";

            var patchOperation = new[]
            {
                new
                {
                    op = "add",
                    path = "/relations/-",
                    value = new
                    {
                        rel = "System.LinkTypes.Related",
                        url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{targetId}",
                        attributes = new
                        {
                            comment = string.IsNullOrEmpty(comment) ? "Auto-generated relation" : comment
                        }
                    }
                }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json-patch+json");

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to create relation from #{SourceId} to #{TargetId}. Status: {StatusCode}, Content: {Content}",
                    sourceId, targetId, response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to create relation with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully created relation from #{SourceId} to #{TargetId}", sourceId, targetId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating relation from #{SourceId} to #{TargetId}", sourceId, targetId);
            throw;
        }
    }

    #endregion

    #region Resource Management

    public void Dispose()
    {
        _httpClient?.Dispose();
    }

    #endregion

    #region Private Helper Methods

    private async Task<IEnumerable<int>> ExecuteWiqlQueryAsync(string wiqlQuery, CancellationToken cancellationToken)
    {
        var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/wiql?api-version=7.0";

        var queryRequest = new { query = wiqlQuery };
        var jsonContent = JsonSerializer.Serialize(queryRequest, _jsonOptions);
        var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");

        // Print the full WIQL query to the console for debugging
        Console.WriteLine("************************************************************");
        Console.WriteLine($"EXECUTING WIQL QUERY: {wiqlQuery}");
        Console.WriteLine($"URL: {url}");
        Console.WriteLine("************************************************************");

        _logger.LogInformation("Executing WIQL query: {Query}", wiqlQuery);
        _logger.LogDebug("Making request to URL: {Url}", url);

        var response = await _httpClient.PostAsync(url, content, cancellationToken);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
            _logger.LogError("WIQL query failed. Status: {StatusCode}, Content: {Content}", response.StatusCode, errorContent);
            throw new HttpRequestException($"WIQL query failed with status {response.StatusCode}: {errorContent}");
        }

        var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);
        var queryResult = JsonSerializer.Deserialize<WiqlQueryResult>(responseContent, _jsonOptions);

        return queryResult?.WorkItems?.Select(wi => wi.Id) ?? Enumerable.Empty<int>();
    }
    private async Task<IEnumerable<WorkItem>> GetWorkItemsByIdsAsync(IEnumerable<int> workItemIds, CancellationToken cancellationToken)
    {
        var ids = string.Join(",", workItemIds);        // Include the fields parameter to ensure we get all necessary fields including IterationPath
        var fields = "System.Id,System.Title,System.WorkItemType,System.State,System.Description,Skype.StatusNotes,System.IterationPath,System.Tags,Microsoft.VSTS.Common.StackRank,Skype.Swag";
        var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems?ids={ids}&fields={fields}&api-version=7.0";

        _logger.LogDebug("Retrieving work items by IDs: {Ids}", ids);
        _logger.LogDebug("Making request to URL: {Url}", url);

        var response = await _httpClient.GetAsync(url, cancellationToken);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
            _logger.LogError("Failed to retrieve work items. Status: {StatusCode}, Content: {Content}", response.StatusCode, errorContent);
            throw new HttpRequestException($"Failed to retrieve work items with status {response.StatusCode}: {errorContent}");
        }
        var content = await response.Content.ReadAsStringAsync(cancellationToken);
        var workItemsResponse = JsonSerializer.Deserialize<WorkItemsResponse>(content, _jsonOptions);

        // Convert work items to dictionary for quick lookup
        var workItemsDict = workItemsResponse?.Value?
            .Select(ConvertToWorkItem)
            .ToDictionary(wi => wi.Id, wi => wi) ?? new Dictionary<int, WorkItem>();

        // Return work items in the same order as the input IDs
        return workItemIds
            .Where(id => workItemsDict.ContainsKey(id))
            .Select(id => workItemsDict[id]);
    }
    private WorkItem ConvertToWorkItem(WorkItemResponse? response)
    {
        if (response?.Fields == null)
            return new WorkItem();

        // Debugging output to see what's coming from ADO for StackRank
        var stackRankValue = GetFieldValue(response.Fields, "Microsoft.VSTS.Common.StackRank");

        double? stackRank = null;
        if (stackRankValue != null)
        {
            if (double.TryParse(stackRankValue, out var stackRankDouble))
            {
                stackRank = stackRankDouble;
            }
            else
            {
                Console.WriteLine($"DEBUG: Failed to parse StackRank value: '{stackRankValue}'");
            }
        }
        return new WorkItem
        {
            Id = response.Id,
            Title = GetFieldValue(response.Fields, "System.Title") ?? string.Empty,
            WorkItemType = GetFieldValue(response.Fields, "System.WorkItemType") ?? string.Empty,
            State = GetFieldValue(response.Fields, "System.State") ?? string.Empty,
            Description = GetFieldValue(response.Fields, "System.Description") ?? string.Empty,
            StatusNotes = GetFieldValue(response.Fields, "Skype.StatusNotes") ?? string.Empty,
            IterationPath = GetFieldValue(response.Fields, "System.IterationPath"),
            Tags = GetFieldValue(response.Fields, "System.Tags") ?? string.Empty,
            StackRank = stackRank,
            Swag = GetSwagValue(response.Fields),
            Relations = new List<WorkItemRelation>() // Empty relations list since we didn't request them
        };
    }
    private WorkItem ConvertToWorkItemWithRelations(WorkItemResponse? response)
    {
        // Get the base work item without relations
        var workItem = ConvertToWorkItem(response);

        // Now add the relations if available
        if (response?.Relations != null)
        {
            workItem.Relations = response.Relations
                .Select(r => new WorkItemRelation
                {
                    Rel = r.Rel ?? string.Empty,
                    Url = r.Url ?? string.Empty,
                    Attributes = r.Attributes != null ? new RelationAttributes
                    {
                        Comment = r.Attributes.Value.TryGetProperty("comment", out var comment) ? comment.GetString() : null,
                        Name = r.Attributes.Value.TryGetProperty("name", out var name) ? name.GetString() : null
                    } : null
                })
                .ToList();
        }

        return workItem;
    }
    private static string? GetFieldValue(Dictionary<string, JsonElement> fields, string key)
    {
        if (fields.TryGetValue(key, out var element))
        {
            if (element.ValueKind == JsonValueKind.String)
            {
                return element.GetString();
            }
            else if (element.ValueKind == JsonValueKind.Number)
            {
                // Handle numeric values by converting them to string
                if (element.TryGetDouble(out var doubleValue))
                {
                    return doubleValue.ToString();
                }
                else if (element.TryGetInt32(out var intValue))
                {
                    return intValue.ToString();
                }
            }
            else if (element.ValueKind == JsonValueKind.Object && element.TryGetProperty("displayName", out var displayName))
            {
                return displayName.GetString();
            }
        }
        return null;
    }
    private static double? GetSwagValue(Dictionary<string, JsonElement> fields)
    {
        var swagValue = GetFieldValue(fields, "Skype.Swag");
        if (swagValue != null && double.TryParse(swagValue, out var swag))
        {
            return swag;
        }
        return null;
    }

    private async Task<int> CreateWorkItemAsync(string workItemType, string title, string areaPath)
    {
        var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/${workItemType}?api-version=7.0";

        _logger.LogDebug($"Creating {workItemType} with title: {title}");
        _logger.LogDebug($"Making request to URL: {url}");        // Create document with the fields for the new work item
        var patchDocument = new[]
        {
            new { op = "add", path = "/fields/System.Title", value = title },
            new { op = "add", path = "/fields/System.AreaPath", value = areaPath },
            new { op = "add", path = "/fields/System.Tags", value = "auto-generated" },
            new { op = "add", path = "/fields/System.Description", value = $"Auto-generated {workItemType} created on {DateTime.Now:yyyy-MM-dd HH:mm:ss}" }
        };

        var jsonContent = JsonSerializer.Serialize(patchDocument, _jsonOptions);

        // ADO requires a specific content type for PATCH operations
        var content = new StringContent(jsonContent, Encoding.UTF8, "application/json-patch+json");

        var response = await _httpClient.PatchAsync(url, content);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            _logger.LogError($"Failed to create {workItemType}. Status: {response.StatusCode}, Content: {errorContent}");
            throw new HttpRequestException($"Failed to create {workItemType} with status {response.StatusCode}: {errorContent}");
        }

        var responseContent = await response.Content.ReadAsStringAsync();
        var workItem = JsonSerializer.Deserialize<WorkItemResponse>(responseContent, _jsonOptions);

        return workItem?.Id ?? 0;
    }

    private async Task CreateRelationsAsync(int parentId, List<int> childrenIds)
    {
        if (childrenIds == null || !childrenIds.Any())
        {
            return;
        }

        var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{parentId}?api-version=7.0";

        _logger.LogDebug($"Creating relations for work item #{parentId} to {childrenIds.Count} children");

        // Add a relation for each child
        var patchOperations = childrenIds.Select(childId => new
        {
            op = "add",
            path = "/relations/-",
            value = new
            {
                rel = "System.LinkTypes.Related",
                url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{childId}",
                attributes = new
                {
                    comment = "Auto-generated relation"
                }
            }
        }).ToList();

        var jsonContent = JsonSerializer.Serialize(patchOperations, _jsonOptions);
        var content = new StringContent(jsonContent, Encoding.UTF8, "application/json-patch+json");

        var response = await _httpClient.PatchAsync(url, content);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            _logger.LogError($"Failed to create relations for work item #{parentId}. Status: {response.StatusCode}, Content: {errorContent}");
            throw new HttpRequestException($"Failed to create relations for work item #{parentId} with status {response.StatusCode}: {errorContent}");
        }

        _logger.LogInformation($"Successfully created {childrenIds.Count} relations for work item #{parentId}");
    }
    public async Task UpdateWorkItemTitleAsync(int workItemId, string newTitle)
    {
        try
        {
            _logger.LogInformation("Updating work item #{WorkItemId} title to: {NewTitle}", workItemId, newTitle);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?api-version=7.0";

            var patchOperation = new[]
            {
                new
                {
                    op = "replace",
                    path = "/fields/System.Title",
                    value = newTitle
                }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json-patch+json");

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to update work item #{WorkItemId} title. Status: {StatusCode}, Content: {Content}",
                    workItemId, response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to update work item title with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully updated work item #{WorkItemId} title", workItemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating work item #{WorkItemId} title", workItemId);
            throw;
        }
    }

    public async Task UpdateWorkItemSwagAsync(int workItemId, double swagValue)
    {
        try
        {
            _logger.LogInformation("Updating work item #{WorkItemId} SWAG to: {SwagValue}", workItemId, swagValue);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?api-version=7.0"; var patchOperation = new[]
            {
                new
                {
                    op = "replace",
                    path = "/fields/Skype.Swag",
                    value = swagValue
                }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json-patch+json");

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to update work item #{WorkItemId} SWAG. Status: {StatusCode}, Content: {Content}",
                    workItemId, response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to update work item SWAG with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully updated work item #{WorkItemId} SWAG", workItemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating work item #{WorkItemId} SWAG", workItemId);
            throw;
        }
    }    /// <summary>
         /// Updates a work item's status notes with SWAG prefix
         /// </summary>
         /// <param name="workItemId">ID of the work item to update</param>
         /// <param name="swagValue">The SWAG value to add as prefix</param>
         /// <param name="originalStatusNotes">The original status notes</param>
         /// <returns>Task representing the asynchronous operation</returns>
    public async Task UpdateWorkItemStatusNotesWithSwagAsync(int workItemId, double swagValue, string originalStatusNotes)
    {
        try
        {
            _logger.LogInformation("Updating work item #{WorkItemId} status notes with SWAG prefix: {SwagValue}", workItemId, swagValue);

            var url = $"{_options.BaseUrl}/{_options.Project}/_apis/wit/workitems/{workItemId}?api-version=7.0";            // Remove existing SWAG prefix if present and add new one
            var cleanStatusNotes = RemoveSwagPrefixFromDescription(originalStatusNotes);

            // Add SWAG prefix to the cleaned status notes
            string newStatusNotes = $"[SWAG: {swagValue}]{cleanStatusNotes}";
            var patchOperation = new[]
            {
                new
                {
                    op = "replace",
                    path = "/fields/Skype.StatusNotes",
                    value = newStatusNotes
                }
            };

            var jsonContent = JsonSerializer.Serialize(patchOperation, _jsonOptions);
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json-patch+json");

            var response = await _httpClient.PatchAsync(url, content);

            if (!response.IsSuccessStatusCode)
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogError("Failed to update work item #{WorkItemId} status notes with SWAG. Status: {StatusCode}, Content: {Content}",
                    workItemId, response.StatusCode, errorContent);
                throw new HttpRequestException($"Failed to update work item status notes with SWAG with status {response.StatusCode}: {errorContent}");
            }

            _logger.LogInformation("Successfully updated work item #{WorkItemId} status notes with SWAG prefix", workItemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating work item #{WorkItemId} status notes with SWAG", workItemId);
            throw;
        }
    }    /// <summary>
         /// Removes existing SWAG prefix from status notes if present
         /// </summary>
         /// <param name="description">The status notes to clean</param>
         /// <returns>Status notes without SWAG prefix</returns>
    private static string RemoveSwagPrefixFromDescription(string description)
    {
        if (string.IsNullOrEmpty(description))
            return description;

        // Look for pattern [SWAG: number] at the beginning
        var pattern = @"^\[SWAG:\s*\d+(?:\.\d+)?\]";
        var regex = new System.Text.RegularExpressions.Regex(pattern);

        return regex.Replace(description, "").TrimStart();
    }

    /// <summary>
    /// Extracts SWAG value from status notes if present
    /// </summary>
    /// <param name="description">The status notes to parse</param>
    /// <returns>SWAG value if found, null otherwise</returns>
    public static double? ExtractSwagFromDescription(string description)
    {
        if (string.IsNullOrEmpty(description))
            return null;

        // Look for pattern [SWAG: number] at the beginning
        var pattern = @"^\[SWAG:\s*(\d+(?:\.\d+)?)\]";
        var regex = new System.Text.RegularExpressions.Regex(pattern);
        var match = regex.Match(description);

        if (match.Success && double.TryParse(match.Groups[1].Value, out var swagValue))
        {
            return swagValue;
        }

        return null;
    }

    private async Task<IEnumerable<WorkItem>> GetWorkItemsWithRelationsByIdsAsync(IEnumerable<int> workItemIds, CancellationToken cancellationToken)
    {
        // For hygiene checks, we need to get each work item individually with relations
        // since the batch API doesn't support expanding relations for multiple items
        var workItems = new List<WorkItem>();

        foreach (var id in workItemIds)
        {
            var workItem = await GetWorkItemWithRelationsAsync(id, cancellationToken);
            if (workItem != null)
            {
                workItems.Add(workItem);
            }
        }
        return workItems;
    }

    #endregion

    #region SWAG Specific Methods

    public async Task<IEnumerable<WorkItem>> GetWorkItemsForSwagUpdatesAsync(int limit, string areaPath, CancellationToken cancellationToken = default)
    {
        try
        {
            // WIQL query to retrieve both Feature and Release Train work items for SWAG updates
            // Include closed Features since completed work should count toward SWAG calculations
            var wiqlQuery = $"SELECT [System.Id] FROM WorkItems WHERE [System.WorkItemType] IN ('Feature', 'Release Train') AND [System.AreaPath] UNDER '{areaPath}' AND [System.State] NOT IN ('Removed') ORDER BY [Microsoft.VSTS.Common.StackRank] ASC, [System.Id] ASC";
            var workItemIds = await ExecuteWiqlQueryAsync(wiqlQuery, cancellationToken);

            // Take only the requested number of IDs
            var limitedIds = workItemIds.Take(Math.Min(limit, 1000));

            if (!limitedIds.Any())
            {
                _logger.LogInformation("No Feature or Release Train work items found for SWAG updates.");
                return Enumerable.Empty<WorkItem>();
            }

            _logger.LogInformation("Found {Count} Feature/Release Train work items for SWAG updates (including closed), retrieving {Limit}", workItemIds.Count(), limitedIds.Count());

            // Get the full work item details with relations for SWAG updates
            return await GetWorkItemsWithRelationsByIdsAsync(limitedIds, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving work items for SWAG updates");
            throw;
        }
    }

    #endregion
}

// Internal response models for Azure DevOps API
internal class WiqlQueryResult
{
    public List<WorkItemReference>? WorkItems { get; set; }
}

internal class WorkItemReference
{
    public int Id { get; set; }
}

internal class WorkItemsResponse
{
    public List<WorkItemResponse>? Value { get; set; }
}

internal class WorkItemResponse
{
    public int Id { get; set; }
    public Dictionary<string, JsonElement>? Fields { get; set; }
    public string? Url { get; set; }
    public List<WorkItemRelationResponse>? Relations { get; set; }
}

internal class WorkItemRelationResponse
{
    public string? Rel { get; set; }
    public string? Url { get; set; }
    public JsonElement? Attributes { get; set; }
}

